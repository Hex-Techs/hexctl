package run

import (
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"

	"github.com/Hex-Techs/hexctl/pkg/common/file"
	"github.com/fsnotify/fsnotify"
	"github.com/gookit/color"
)

var (
	eventTime           = make(map[string]int64)
	watchExts           = []string{".go", ".html", ".tmpl"}
	ignoredFilesRegExps = []string{
		`.#(\w+).go$`,
		`.(\w+).go.swp$`,
		`(\w+).go~$`,
		`(\w+).tmp$`,
	}
)

// NewWatcher starts an fsnotify Watcher on the specified paths
func NewWatcher(pathchan chan string, stop chan bool) {
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		color.Red.Println("Failed to create watcher:", err)
	}
	defer watcher.Close()
	go func() {
		for {
			select {
			case e, ok := <-watcher.Events:
				if !ok {
					return
				}
				op := e.Op.String()
				if file.IsDir(e.Name) {
					if op == "CREATE" {
						pathchan <- e.Name
					}
					continue
				}
				// Skip ignored files
				if shouldIgnoreFile(e.Name) {
					continue
				}
				if !shouldWatchFileWithExtension(e.Name) {
					continue
				}
				var mt int64
				if op == "CREATE" || op == "WRITE" {
					mt = getFileModTime(e.Name)
				}
				if op == "CREATE" || op == "REMOVE" || op == "WRITE" {
					if mt == eventTime[e.Name] {
						continue
					}
					stop <- true
					color.Green.Println("Reload Progess...")
				}
				eventTime[e.Name] = mt
			case err, ok := <-watcher.Errors:
				if !ok {
					return
				}
				color.Red.Println("Watcher error:", err) // No need to exit here
			}
		}
	}()

	color.Green.Println("Initializing Watcher...")

	for {
		path := <-pathchan
		color.Yellow.Println("Watching: ", path)
		err = watcher.Add(path)
		if err != nil {
			color.Red.Println("Failed to watch directory:", err)
		}
	}
}

// shouldIgnoreFile ignores filenames generated by Emacs, Vim or SublimeText.
// It returns true if the file should be ignored, false otherwise.
func shouldIgnoreFile(filename string) bool {
	for _, regex := range ignoredFilesRegExps {
		r, err := regexp.Compile(regex)
		if err != nil {
			color.Red.Println("Could not compile regular expression:", err)
		}
		if r.MatchString(filename) {
			return true
		}
		continue
	}
	return false
}

// shouldWatchFileWithExtension returns true if the name of the file
// hash a suffix that should be watched.
func shouldWatchFileWithExtension(name string) bool {
	for _, s := range watchExts {
		if strings.HasSuffix(name, s) {
			return true
		}
	}
	return false
}

func getFileModTime(path string) int64 {
	path = strings.Replace(path, "\\", "/", -1)
	f, err := os.Open(path)
	if err != nil {
		color.Red.Printf("Failed to open file on '%s': %s", path, err)
		return time.Now().Unix()
	}
	defer f.Close()

	fi, err := f.Stat()
	if err != nil {
		color.Red.Printf("Failed to get file stats: %s", err)
		return time.Now().Unix()
	}

	return fi.ModTime().Unix()
}

// GetDirList get a list of dir
func GetDirList(dirpath string) ([]string, error) {
	var dirList []string
	err := filepath.Walk(dirpath,
		func(path string, f os.FileInfo, err error) error {
			if f == nil {
				return err
			}
			if f.IsDir() {
				dirList = append(dirList, path)
				return nil
			}

			return nil
		})
	return dirList, err
}
